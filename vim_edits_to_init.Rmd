---
title: "Old init.vim excerpts"
---

TIP: Renaming using vim:
https://vi.stackexchange.com/questions/18004/renaming-variables
My own autopairs
https://stackoverflow.com/questions/13404602/how-to-prevent-esc-from-waiting-for-more-input-in-insert-mode
https://vim.fandom.com/wiki/Automatically_append_closing_characters (see the
plugins at the end of the webpage)
"NOTE: Unless both ( and (<CR> are bound, FastEscape won't affect them. In
"other words, if only the character itself is bound rather than a key sequence
"starting with the character, FastEscape is ignored! That's awesome.
augroup FastEscape
      autocmd!
      au InsertEnter * set timeoutlen=500
      au InsertLeave * set timeoutlen=1000
augroup END
Autopair mappings:
https://vim.fandom.com/wiki/Automatically_append_closing_characters

Example for Vim. Vim indents on a line following :fu. <C-d> deletes the
indentation, then <C-o> inserts a line above that is auto-indented
"inoremap (<CR> (<CR><C-d>)<C-o>O


Note that submodes can not accommodate counts. You could investigate
tinykeymap, but I couldn't get window movement to work:
https://github.com/vim-scripts/tinykeymap/blob/master/autoload/tinykeymap/map/windows.vim
Doing so would enable proper use of c-w x, for swapping w/ the n-th window
Submodes also don't seem to support commands in {RHS}

Using tmux and vim:
https://statico.github.io/vim3.html
The example here is a vim binding to execute the previous command in a
terminal's command histroy. It relies on tmux to send keys between
terminals. This is useful if you're editing a script and want to test it. Of
course, this can probably be done in vim directly.

For LSP with R, see either LanguageClient-neovim or coc-r-lsp and coc.nvim:
https://cran.r-project.org/web/packages/languageserver/readme/README.html
Note that only LC-neovim, not coc.nvim, is designed to integrate with ncm2
and thus ncm-r. ALthough code is provided to integrate somewhat:
https://github.com/ncm2/ncm2/issues/51
Is this true? What about b:coc_suggest_disable? Or is this issue using coc
for completion?
https://cran.r-project.org/web/packages/languageserver/readme/README.html
General tutorial:
https://jacky.wtf/weblog/language-client-and-neovim/
Consider coc.nvim for other languages:
https://www.narga.net/how-to-set-up-code-completion-for-vim/#why_is_cocvim
syntastics vs ale vs coc.nvim

Windoes management sucks. See:
https://github.com/spolu/dwm.vim
https://www.reddit.com/r/vim/comments/3htkd7/rotate_windows_clockwise_anticlockwise/

Neovim GUIs and packages:
https://github.com/neovim/neovim/wiki/Related-projects

Example of calling function from command (see f-args)
    function! MyEdit(x)
        " Disable partial matching for :sb and avoid errors for non-matches
        if bufexists(a:x)
            execute 'sb' a:x
        else
            execute 'buffer' a:x
        endif
    endfunction
    command! -bang -nargs=1 Test call MyEdit(<f-args>)

TODO: Parse lines to get keys bound to each submode, invert, write vim commands,
save to file, then source in vim
By default, any unbound key exits the mode. Therefore, to prevent any key
but the desired exit key from leaving the submode, bind all unused keys
to <Nop>. See submode#unmap
function! s:getmap()
    silent !rm -f ~/.config/nvim/map.txt
    redir > ~/.config/nvim/map.txt
    silent map
    redir END
endfunction
autocmd VimEnter * call s:getmap()

function! s:csk()
    silent !rm -f temp
    redir > temp
    silent echo ctrlspace#keys#KeyMap()
    redir END
endfunction
autocmd VimEnter * call s:csk()

Tags (in R)
https://docs.ctags.io/en/latest/index.htmf
https://ricostacruz.com/til/navigate-code-with-ctags (see shortcuts)
https://www.fusionbox.com/blog/detail/navigating-your-django-project-with-vim-and-ctags/590/
https://vim.fandom.com/wiki/Browsing_programs_with_tags" https://github.com/lyuts/vim-rtags

You can generate tags for R in ctags, or use rtags and etags2ctags
https://tinyheero.github.io/2017/05/13/r-vim-ctags.html
https://stackoverflow.com/questions/4794859/exuberant-ctags-with-r
etags2ctags is provided by nvim-r

function! <SID>NewOrOpen()
    let ntbufl = filter(map(tabpagebuflist(tabpagenr()), 'getbufinfo(v:val)[0]'), 'has_key(v:val.variables, "neoterm_id")')
    if len(ntbufl) > 0
        " let ntbuf = ntbufl[0].bufnr
        " exec g:neoterm_default_mod.' split '.bufname(ntbuf)
        Topen
    else
        Tnew
    endif
endfunction
nnoremap <localleader>o :<c-u>call <SID>NewOrOpen()<CR>


Reason for double backslashes: |literal-string| or the paragraph above
|expr5|. This seems similar to R's need for double backslashes. In R,
string processing is followed by regex processing when using a regex
function. In VIM, it seems that double qutoes, rather than a regex function
like grep(), are the trigger. Here are examples from my edits to the neoterm
plugin:
let pycommand = filter(a:command, 'v:val !~ "^\\s*$"')
let prev_indent = len(matchstr(prev_line, '^\s*'))

= Neoterm =

" Input is sent to the last active terminal or the terminal whose ID matches
" the numeric prefix of the command. Note that :[N]<command> really means
" press N, then :<command>. If you want to allow a numeric prefix in mapped
" commands, don't use <c-u> to clear the range.
" neoterm automatically increments the termid for each new terminal made
" by :Tnew. This makes using commands that take termid as a range/count
" difficult, beause there's the counter doesn't decrement after killing a
" terminal (as opposed to hiding it). An alternative is to associate each
" terminal with a tab and to omit counts altogether, using
" g:neoterm_term_per_tab. Using :Topen or :Ttoggle instead
" of :Tnew ensures only one terminal per tab.

" Note. If full text isn't showing up in terminal, but no errors are thrown,
" increase sleep.
function! Test(...) range
    " if (g:neoterm_repl_command =~ 'ipython')
    let lines = getline(a:firstline, a:lastline)
    call neoterm#exec({'cmd': ['%cpaste -q', '']})
    sleep 100m
    call neoterm#exec({'cmd': add(lines, '')})
    sleep 100m
    call neoterm#exec({'cmd': ['--', '']})
    " endif
endfunction

map <localleader>z :call Test()<cr>


## From my macOS nvim config
" nvim-gdb configuration
" disable dd, dl, and db; configure dpy to use python3 instead of python2
let g:nvimgdb_disable_start_keymaps=1
nnoremap <leader>dpy :GdbStartPDB python3 -m pdb main.py
" Disable these key (re?)mappings in Terminal mode; enable in normal
let g:nvimgdb_config_override = {
  \ 'key_until': '<leader>du',
  \ 'key_continue': '<leader>dc',
  \ 'key_next': '<leader>dn',
  \ 'key_step': '<leader>ds',
  \ 'key_finish': '<leader>df',
  \ 'key_breakpoint': '<leader>db',
  \ 'key_frameup': '<leader>dp',
  \ 'key_framedown': '<leader>dn',
  \ 'key_eval': '<leader>de',
  \ 'set_tkeymaps': "NvimGdbNoTKeymaps",
  \ }
" TODO: Investigate whether key_eval binds both normal and visual eval


"Investigate:
" SimplyFold
" git
"   vim-fugitive
" indent
"   vim-python-pep8-indent<F13>
" completion
"   youcompleteme
"   ncm2
"   deoplete
"   jedi-vim
"   completor.vim
" lint
"   ale
"   languageclient-neovim
"   vim-flake8
"syntax
"   python-syntax
"   python-mode
"autoformat
"   yapf
"   vim-autofromat
"Plugins to investigate
        " honza/vim-snippets
        " dense-analysis/ale
        " autocomplete
                " youcompleteme
        "vim-markdown
        "supertab
        " vim-multiple-cursors
        " tpope/sensible-vim
        " vim-gitgutter
        " powerline or vim-airline and/or vim-airline-themes (select one without Univode for WSL)
        "   Plugin 'Lokaltog/powerline', {'rtp': 'powerline/bindings/vim/'}
        " ctrlp
        " tabular
        " denite or fzf
        " undotree
        " indent guides
        " vim-surround
        " vim-endwise
        " commentary
        " matchit (see https://catonmat.net/vim-plugins-matchit-vim)
"Outdated plugins that need to be rewritten
        "Plug 'dag/vim-fish'

